<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="description" content="谷歌Project Tango使用文档的中文翻译。">
<meta name="author" content="Jin Jay">
<meta name="image" content="images/APIDiagram.png">
<meta name="date" content="2017-03">
<meta name="keywords" content="Project Tango,增强现实,Augmented Reality"><style>
</style><style>.codehilite pre .hll { background-color: #ffffcc }
.codehilite pre  { background: #f0f3f3; }
.codehilite pre .c { color: #0099FF; font-style: italic } /* Comment */
.codehilite pre .err { color: #AA0000; background-color: #FFAAAA } /* Error */
.codehilite pre .k { color: #006699; font-weight: bold } /* Keyword */
.codehilite pre .o { color: #555555 } /* Operator */
.codehilite pre .ch { color: #0099FF; font-style: italic } /* Comment.Hashbang */
.codehilite pre .cm { color: #0099FF; font-style: italic } /* Comment.Multiline */
.codehilite pre .cp { color: #009999 } /* Comment.Preproc */
.codehilite pre .cpf { color: #0099FF; font-style: italic } /* Comment.PreprocFile */
.codehilite pre .c1 { color: #0099FF; font-style: italic } /* Comment.Single */
.codehilite pre .cs { color: #0099FF; font-weight: bold; font-style: italic } /* Comment.Special */
.codehilite pre .gd { background-color: #FFCCCC; border: 1px solid #CC0000 } /* Generic.Deleted */
.codehilite pre .ge { font-style: italic } /* Generic.Emph */
.codehilite pre .gr { color: #FF0000 } /* Generic.Error */
.codehilite pre .gh { color: #003300; font-weight: bold } /* Generic.Heading */
.codehilite pre .gi { background-color: #CCFFCC; border: 1px solid #00CC00 } /* Generic.Inserted */
.codehilite pre .go { color: #AAAAAA } /* Generic.Output */
.codehilite pre .gp { color: #000099; font-weight: bold } /* Generic.Prompt */
.codehilite pre .gs { font-weight: bold } /* Generic.Strong */
.codehilite pre .gu { color: #003300; font-weight: bold } /* Generic.Subheading */
.codehilite pre .gt { color: #99CC66 } /* Generic.Traceback */
.codehilite pre .kc { color: #006699; font-weight: bold } /* Keyword.Constant */
.codehilite pre .kd { color: #006699; font-weight: bold } /* Keyword.Declaration */
.codehilite pre .kn { color: #006699; font-weight: bold } /* Keyword.Namespace */
.codehilite pre .kp { color: #006699 } /* Keyword.Pseudo */
.codehilite pre .kr { color: #006699; font-weight: bold } /* Keyword.Reserved */
.codehilite pre .kt { color: #007788; font-weight: bold } /* Keyword.Type */
.codehilite pre .m { color: #FF6600 } /* Literal.Number */
.codehilite pre .s { color: #CC3300 } /* Literal.String */
.codehilite pre .na { color: #330099 } /* Name.Attribute */
.codehilite pre .nb { color: #336666 } /* Name.Builtin */
.codehilite pre .nc { color: #00AA88; font-weight: bold } /* Name.Class */
.codehilite pre .no { color: #336600 } /* Name.Constant */
.codehilite pre .nd { color: #9999FF } /* Name.Decorator */
.codehilite pre .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite pre .ne { color: #CC0000; font-weight: bold } /* Name.Exception */
.codehilite pre .nf { color: #CC00FF } /* Name.Function */
.codehilite pre .nl { color: #9999FF } /* Name.Label */
.codehilite pre .nn { color: #00CCFF; font-weight: bold } /* Name.Namespace */
.codehilite pre .nt { color: #330099; font-weight: bold } /* Name.Tag */
.codehilite pre .nv { color: #003333 } /* Name.Variable */
.codehilite pre .ow { color: #000000; font-weight: bold } /* Operator.Word */
.codehilite pre .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite pre .mb { color: #FF6600 } /* Literal.Number.Bin */
.codehilite pre .mf { color: #FF6600 } /* Literal.Number.Float */
.codehilite pre .mh { color: #FF6600 } /* Literal.Number.Hex */
.codehilite pre .mi { color: #FF6600 } /* Literal.Number.Integer */
.codehilite pre .mo { color: #FF6600 } /* Literal.Number.Oct */
.codehilite pre .sa { color: #CC3300 } /* Literal.String.Affix */
.codehilite pre .sb { color: #CC3300 } /* Literal.String.Backtick */
.codehilite pre .sc { color: #CC3300 } /* Literal.String.Char */
.codehilite pre .dl { color: #CC3300 } /* Literal.String.Delimiter */
.codehilite pre .sd { color: #CC3300; font-style: italic } /* Literal.String.Doc */
.codehilite pre .s2 { color: #CC3300 } /* Literal.String.Double */
.codehilite pre .se { color: #CC3300; font-weight: bold } /* Literal.String.Escape */
.codehilite pre .sh { color: #CC3300 } /* Literal.String.Heredoc */
.codehilite pre .si { color: #AA0000 } /* Literal.String.Interpol */
.codehilite pre .sx { color: #CC3300 } /* Literal.String.Other */
.codehilite pre .sr { color: #33AAAA } /* Literal.String.Regex */
.codehilite pre .s1 { color: #CC3300 } /* Literal.String.Single */
.codehilite pre .ss { color: #FFCC33 } /* Literal.String.Symbol */
.codehilite pre .bp { color: #336666 } /* Name.Builtin.Pseudo */
.codehilite pre .fm { color: #CC00FF } /* Name.Function.Magic */
.codehilite pre .vc { color: #003333 } /* Name.Variable.Class */
.codehilite pre .vg { color: #003333 } /* Name.Variable.Global */
.codehilite pre .vi { color: #003333 } /* Name.Variable.Instance */
.codehilite pre .vm { color: #003333 } /* Name.Variable.Magic */
.codehilite pre .il { color: #FF6600 } /* Literal.Number.Integer.Long */</style><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>Project Tango</title>
    <meta name="robots" content="all" />
    <!-- TODO: 移动设备配置 -->
    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="../../images/snow.jpg">
    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="JinJay">
    <link rel="apple-touch-icon-precomposed" href="../../images/snow.jpg">
    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="../../images/snow.jpg">
    <meta name="msapplication-TileColor" content="#3372DF">
    <!-- save to local storage -->
    <link href="../../mdl/icon.css" rel="stylesheet">
    <link href="http://cdn.bootcss.com/material-design-icons/3.0.1/iconfont/material-icons.min.css" rel="stylesheet">
    <!-- random generate color -->
    <link rel="stylesheet" href="../../mdl/material.lime-blue.min.css" />
    <!-- template.css -->
    <link rel="stylesheet" type="text/css" href="../../stylesheets/t.css">
    <script src="../../mdl/material.min.js"></script>
  </head>
  <body>
    <!-- Uses a header that contracts as the page scrolls down. -->
    <style>
    .waterfall-demo-header-nav .mdl-navigation__link:last-of-type {
    padding-right: 0;
    }
    }
    </style>
    <div class="mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-layout--overlay-drawer-button">
      <header class="mdl-layout__header mdl-layout__header--waterfall">
        <!-- Top row, always visible -->
        <div class="mdl-layout__header-row">
          <!-- TOC -->
          <span class="mdl-layout-title">目录</span>
          <div class="mdl-layout-spacer"></div>
          <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable
            mdl-textfield--floating-label mdl-textfield--align-right">
            <label class="mdl-button mdl-js-button mdl-button--icon" for="waterfall-exp">
              <i class="material-icons">search</i>
            </label>
            <div class="mdl-textfield__expandable-holder">
              <input class="mdl-textfield__input" type="text" name="sample" id="waterfall-exp" placeholder="暂不可用" />
            </div>
          </div>
        </div>
        <!-- Bottom row, not visible on scroll -->
        <div class="mdl-layout__header-row">
          <span class="mdl-layout-tile mdl-layout--large-screen-only">朝着梦想，一步一步！</span>
          <div class="mdl-layout-spacer"></div>
          <!-- Navigation -->
          <nav class="waterfall-demo-header-nav mdl-navigation">
            <a class="mdl-navigation__link" href="http://jinjaysnow.github.io">主页</a>
            <a class="mdl-navigation__link" href="http://jinjaysnow.github.io/blog/">博客</a>
            <a class="mdl-navigation__link" href="http://jinjaysnow.github.io/about.html">关于我</a>
          </nav>
        </div>
      </header>
      <div class="mdl-layout__drawer">
        <span class="mdl-layout-title">目录</span>
        <nav class="mdl-navigation">
          <div class="toc">
<ul>
<li><a href="#tango">Tango开发概览</a><ul>
<li><a href="#_1">背景知识</a><ul>
<li><a href="#_2">坐标系</a></li>
<li><a href="#_3">坐标帧转换</a></li>
<li><a href="#_4">引用帧</a><ul>
<li><a href="#_5">运动追踪的坐标帧</a></li>
<li><a href="#_6">组件对齐的坐标帧</a></li>
</ul>
</li>
<li><a href="#_7">内参/外参</a><ul>
<li><a href="#tango-api">使用Tango API获取内部参数</a></li>
<li><a href="#tango-api_1">使用Tango API获取外部参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_8">运动追踪</a><ul>
<li><a href="#_9">使用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </nav>
      </div>
      <!-- main outer -->
      <main class="demo-main mdl-layout__content">
      <!-- grid start -->
      <div class="demo-container mdl-grid">
        <!-- placeholder cell -->
        <div class="mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone"></div>
        <div class="demo-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col">
          <h1 id="tango"><a name="user-content-tango" href="#tango" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Tango开发概览</h1>
<p>Tango是利用计算机视觉技术来使得设备能够理解其在真实环境中的姿态的技术平台。Tango设备一般配备有一个广角相机(鱼眼相机)、一个深度相机，精确的传感器时间标记和一个能够使应用开发者使用运动追踪、区域学习和深度感知的软件技术堆栈。</p>
<h2 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>背景知识</h2>
<h3 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>坐标系</h3>
<p>Tango使用两个不同的遵循右手法则的坐标系，分别是<strong>右手局部坐标系</strong>和<strong>右手Android坐标系</strong>。</p>
<p><strong>右手局部坐标系:</strong>X轴正方向为水平向右，Z轴竖直向上，Y轴为深度方向垂直向前远离用户。<br />
<img alt="右手局部坐标系" src="../../images/right-hand-local-level.png" /></p>
<p><strong>右手Android坐标系:</strong>X轴正方向为水平向右，Y轴竖直向上，Z轴为垂直向后指向用户。<br />
<img alt="右手Android坐标系" src="../../images/right-hand-android.png" /></p>
<p>使用运动追踪时的坐标系对应关系如下：</p>
<table>
<thead>
<tr>
<th align="left">基础帧</th>
<th align="left">坐标系</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">COORDINATE_FRAME_START_OF_SERVICE</td>
<td align="left">右手局部坐标系</td>
</tr>
<tr>
<td align="left">COORDINATE_FRAME_AREA_DESCRIPTION</td>
<td align="left">右手局部坐标系</td>
</tr>
<tr>
<td align="left">COORDINATE_FRAME_DEVICE</td>
<td align="left">右手Android坐标系</td>
</tr>
</tbody>
</table>
<blockquote>
<p>OpenGL 坐标系</p>
</blockquote>
<p>OpenGL世界坐标和相机坐标使用与右手Android类似的坐标系。<br />
<img alt="OPENGL坐标系" src="../../images/opengl-frames.png" /></p>
<blockquote>
<p>Unity 坐标系</p>
</blockquote>
<p>Unity世界帧和相机帧使用左手坐标系：X轴水平向右，Y轴竖直向上，Z轴垂直向前远离用户。<br />
<img alt="Unity坐标系" src="../../images/unity-frames.png" /></p>
<h3 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>坐标帧转换</h3>
<p>OpenGL和Unity中，世界帧定义了场景的原点，相机帧表示了相机的视点。由Tango API提供的位姿数据必须转换到合适的坐标系下。这里介绍一下转换的数学基础。</p>
<p>使用下面的符号表示来代表可以被用来将一个向量在目标坐标帧和基础组欧标帧间进行转换的矩阵。<br />
$$_{ Target }^{ Base }{ T }$$</p>
<p>举例俩说，使用设备的位姿<code>DEVICE</code>(D)作为目标坐标帧和<code>START_OF_SERVICE</code>(SS)作为基础坐标帧，表示为:<br />
$$_{ SS }^{ D }{ T }$$</p>
<blockquote>
<p>将Tango位姿数据转换到OpenGL坐标系下</p>
</blockquote>
<p>使用两个变换来将Tango位姿数据转换到OpenGL相机坐标帧下。第一个变换将Tango的<code>START_OF_SERVICE</code>(SS)坐标帧转换为<code>OpenGL World</code>(OW)坐标帧。<br />
$$_{ OW }^{ SS }{ T } = \begin{bmatrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;-1&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;1 \end{bmatrix}$$</p>
<p>第二个变换将<code>OpenGL Camera</code>(OC)坐标帧转换为<code>Tango Device</code>(D)下，由于两个帧使用相同的坐标系，所以转换矩阵为单位阵。<br />
$$_{ OC }^{ D }{ T } = \begin{bmatrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \end{bmatrix}$$</p>
<p>通过按序相乘变换矩阵，可以获得从API到OpenGL相机帧的变换矩阵：<br />
$$_{ OC }^{ OW }{ T } = _{ SS }^{ OW }{ T } * _{ D }^{ SS }{ T } * _{ OC }^{ D }{ T }$$</p>
<blockquote>
<p>将Tango位姿数据转换到Unity坐标系下</p>
</blockquote>
<p>与转换为到OpenGL下类似，首先在<code>START_OF_SERVICE</code>(SS)和<code>Unity World</code>（UW)下转换。<br />
$$_{ SS }^{ UW }{ T } = \begin{bmatrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;1 \end{bmatrix}$$</p>
<p>然后是<code>Unity Camera</code>(UC)与<code>Tango Device</code>(D)转换。<br />
$$_{ UC }^{ D }{ T } = \begin{bmatrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;-1&amp;0 \\ 0&amp;0&amp;0&amp;1 \end{bmatrix}$$</p>
<p>连乘得到转换矩阵。<br />
$$_{ UC }^{ UW }{ T } = _{ SS }^{ UW }{ T } * _{ D }^{ SS }{ T } * _{ UC }^{ D }{ T }$$</p>
<h3 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>引用帧</h3>
<p>为了执行运动追踪，设备报告自己的位姿(位置和方向)相对于给定的引用帧，该帧被认为在三维空间中固定不变。举例来说设备报告“相对于我开始运动追踪的地方，我现在在前方三尺、高度一尺的位置，并向右旋转了30度”。这样设备通过使用有意义的方向信息告知了它的位置：从初始位置开始前方三尺，高度一尺；还有当前它的方向，相对于初始位置向右旋转了30度。为了使用运动追踪，需要设定以下两个帧：</p>
<ol>
<li>基础帧，参考帧，在三维空间中固定不变的帧，例<code>COORDINATE_FRAME_START_OF_SERVICE</code>。</li>
<li>目标帧，想要测量的帧，运动追踪中通常为<code>COORDINATE_FRAME_DEVICE</code>。</li>
</ol>
<h4 id="_5"><a name="user-content-_5" href="#_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>运动追踪的坐标帧</h4>
<p>Tango API提供的用于运动追踪的坐标帧如下：</p>
<table>
<thead>
<tr>
<th align="left">目标帧</th>
<th align="left">基础帧</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">COORDINATE_FRAME_DEVICE</td>
<td align="left">COORDINATE_FRAME_START_OF_SERVICE</td>
</tr>
<tr>
<td align="left">COORDINATE_FRAME_DEVICE</td>
<td align="left">COORDINATE_FRAME_AREA_DESCRIPTION</td>
</tr>
<tr>
<td align="left">COORDINATE_FRAME_START_OF_SERVICE</td>
<td align="left">COORDINATE_FRAME_AREA_DESCRIPTION</td>
</tr>
</tbody>
</table>
<h4 id="_6"><a name="user-content-_6" href="#_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>组件对齐的坐标帧</h4>
<table>
<thead>
<tr>
<th align="left">目标帧</th>
<th align="left">基础帧</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">COORDINATE_FRAME_DEVICE</td>
<td align="left">COORDINATE_FRAME_IMU</td>
</tr>
<tr>
<td align="left">COORDINATE_FRAME_CAMERA_COLOR</td>
<td align="left">COORDINATE_FRAME_IMU</td>
</tr>
<tr>
<td align="left">COORDINATE_FRAME_CAMERA_DEPTH</td>
<td align="left">COORDINATE_FRAME_IMU</td>
</tr>
<tr>
<td align="left">COORDINATE_FRAME_CAMERA_FISHEYE</td>
<td align="left">COORDINATE_FRAME_IMU</td>
</tr>
</tbody>
</table>
<p>一些设备需要对齐多个数据源，比如从彩色相机和深度相机获取的数据。可以将<code>COORDINATE_FRAME_IMU</code>作为基础帧，与其他组件目标帧组合。</p>
<p>结合数据中的运动追踪坐标帧和时间戳，计算出的偏移量可以在时间和空间上对多个传感器输入有更深层的了解。这在对齐和组合多个数据源时很有必要。</p>
<p>由于设备设计为刚体模型，这些偏移量被认为不可更改，且在API中也不会发生变化。然而，设备的组件在空间总的位置是变化的。当前Tango API并不会更新外部参数。这些值是在工厂模式下一次标定完成或从工厂的描述设计文件中获取。需要获得更加精确的数据，应用开发者需要实现自己的标定程序来让终端用户执行。</p>
<p><code>COORDINATE_FRAME_IMU</code>基础帧给设备的所有其他组件提供了一个共同的引用点。这个基础帧的原点并不必与其他任一个组件相同，而且可以在设备间变化。与其他的Android传感器类似，设备的坐标帧轴与设备的自然方向对齐。这个工厂定义的方向可能与应用想要的方向并不一致。为了最大化兼容性，不要假定Tango设备有一个自然的<code>landscape</code>或<code>portrait</code>方向。因而，使用Android的<code>getRotation()</code>方法来确定屏幕的旋转，并使用Android的<code>remapCoordinateSystem()</code>方法来将传感器坐标映射到屏幕坐标系。</p>
<h3 id="_7"><a name="user-content-_7" href="#_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>内参/外参</h3>
<p>对设备进行标定时，标定程序执行一系列的测量来了解设备的相机状况。这个测量值称为相机内部参数。这个信息是必要的，举个例子，开发增强现实应用时，需要将虚拟内容渲染在真是的视频帧上，需要保证设备相机的视角(field of view, <strong>FOV</strong>)与虚拟相机的FOV相同。另一个重要的地方是要确保虚拟物体在FOV下指定的位置处。Tango设备通过使用惯性传感器IMU来确定设备的位姿。而相机与IMU的位置并不一致，所以Tango设备的位姿测量值与真实相机的位置会有一个小的偏差。这个偏差，尽管很小，但可能会使得虚拟物体的位置出现错误。故而必须选定一个合适的坐标帧对。组件间的距离被称为外部参数。</p>
<blockquote>
<p>FOV</p>
</blockquote>
<p>视角是指设备从左到右(水平FOV)和从上到下(竖直FOV)能看到的范围，使用度数来表示。</p>
<blockquote>
<p>焦距</p>
</blockquote>
<p>焦距是一个内部参数，可以用来确定FOV的大小，在大多数传统相机上，可以通过调整相机来放大和缩小图像。而Tango设备上，焦距是固定的，需要注意的是：</p>
<ol>
<li>在通过Tango API获取内部参数时，获得的是两个焦距值x和y。</li>
<li>必须在方程中使用这些值来确定渲染时的FOV。</li>
</ol>
<h4 id="tango-api"><a name="user-content-tango-api" href="#tango-api" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>使用Tango API获取内部参数</h4>
<div class="codehilite"><pre><span></span><span class="n">TangoCameraIntrinsics</span> <span class="n">ccIntrinsics</span><span class="p">;</span>
<span class="n">TangoService_getCameraIntrinsics</span><span class="p">(</span><span class="n">TANGO_CAMERA_COLOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ccIntrinsics</span><span class="p">);</span>
</pre></div>


<blockquote>
<p>计算相机的FOV</p>
</blockquote>
<p>从Tango API获取的参数如下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">width</td>
<td align="left">图像的像素宽度</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">图像的像素高度</td>
</tr>
<tr>
<td align="left">fx</td>
<td align="left">x轴的焦距，像素为单位</td>
</tr>
<tr>
<td align="left">fy</td>
<td align="left">y轴的焦距，像素为单位</td>
</tr>
</tbody>
</table>
<p>在大多数系统中，$fx = fy$。</p>
<p>举例来说，获取的的数据如下：</p>
<div class="codehilite"><pre><span></span><span class="n">ccIntrinsics</span><span class="p">.</span><span class="n">height</span><span class="o">=</span><span class="mi">720</span><span class="p">;</span>
<span class="n">ccIntrinsics</span><span class="p">.</span><span class="n">fy</span><span class="o">=</span><span class="mf">1042.0</span><span class="p">;</span>
</pre></div>


<p>因此，水平FOV为：</p>
<div class="codehilite"><pre><span></span><span class="n">Vertical</span> <span class="n">FOV</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="mf">720.0</span><span class="o">/</span><span class="mf">1042.0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mf">19.0549</span> <span class="n">deg</span> <span class="o">=</span> <span class="mf">38.1098</span> <span class="n">deg</span>
</pre></div>


<p>水平和竖直FOV的计算方程为:<br />
$$<br />
Horizontal \quad FOV = 2 * atan(0.5 * width / fx) - 2 * \arctan(\frac{width/2}{fx}) \\<br />
Vertical \quad FOV = 2 * atan(0.5 * height / fx) - 2 * \arctan(\frac{height/2}{fx}) <br />
$$</p>
<p>如果渲染引擎只支持一个FOV值，则需要查看引擎文档来确定使用哪一个FOV。如果需要使用对角FOV，方程如下：<br />
$$Diagonal \quad FOV = 2*atan(sqrt((width/2fx)^2 + (height/2fy)^2)) = 2 * \arctan(\frac{height/2}{fy})$$</p>
<blockquote>
<p>Tango相机畸变模型</p>
</blockquote>
<p>相机的镜头存在着缺陷，会有一些畸变的存在。对大多数场景来说，这个畸变可以忽略不计，不过，在一个Tango设备进行标定时，测量并存储了这些畸变信息，可以使用<code>TangoCameraIntrinsics</code>结构来获取。</p>
<p>Tango使用两个镜头畸变模型：<br />
1.如果使用运动追踪相机(鱼眼相机)，那么<code>FOV</code>畸变模型被使用，从结构体中获得标定类型为<code>TANGO_CALIBRATION_EQUIDISTANT</code>。<br />
2. 如果使用彩色相机，那么多项式畸变模型被使用，从结构体重获得的标定类型为<code>TANGO_CALIBRATION_POLYNOMIAL_3_PARAMETERS</code>。</p>
<h4 id="tango-api_1"><a name="user-content-tango-api_1" href="#tango-api_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>使用Tango API获取外部参数</h4>
<p>对于增强现实应用，需要计算IMU和相机之间的位置，这个测量值成为外部参数。因为设备上的组件位置基本不变，所以只需要计算一次即可。</p>
<div class="codehilite"><pre><span></span><span class="c1">//Color Camera Frame with respect to IMU Frame</span>
<span class="n">TangoPoseData</span> <span class="n">cToIMUPose</span><span class="p">;</span>
<span class="n">TangoCoordinateFramePair</span> <span class="n">cToIMUPair</span><span class="p">;</span>
<span class="n">cToIMUPair</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">TANGO_COORDINATE_FRAME_IMU</span><span class="p">;</span>
<span class="n">cToIMUPair</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">TANGO_COORDINATE_FRAME_CAMERA_COLOR</span><span class="p">;</span>
<span class="n">TangoService_getPoseAtTime</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cToIMUPair</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cToIMUPose</span><span class="p">);</span>
<span class="n">cToIMU_position</span> <span class="o">=</span> <span class="n">ToVector</span><span class="p">(</span><span class="n">cToIMUPose</span><span class="p">.</span><span class="n">translation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">cToIMUPose</span><span class="p">.</span><span class="n">translation</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                           <span class="n">cToIMUPose</span><span class="p">.</span><span class="n">translation</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="n">cToIMU_rotation</span> <span class="o">=</span> <span class="n">ToQuaternion</span><span class="p">(</span><span class="n">cToIMUPose</span><span class="p">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                               <span class="n">cToIMUPose</span><span class="p">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">cToIMUPose</span><span class="p">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">cToIMUPose</span><span class="p">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</pre></div>


<p>通过选择合适的坐标帧对来计算两个设备组件的外部参数。</p>
<h2 id="_8"><a name="user-content-_8" href="#_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>运动追踪</h2>
<p>运动追踪指Tango设备能够在三维空间追踪自己的运动和方向。设备上下前后左右移动和旋转都可以知晓。与鼠标的功能类似，但是不限于二维平面，在整个三维空间中都可以使用。</p>
<h3 id="_9"><a name="user-content-_9" href="#_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>使用</h3>
<p>设备在三维空间运动时，会以最高100次每秒的速度来计算位置和方向。每次计算的结果称为设备的位姿。Tango API 提供了两种方式来获取位姿数据：回调函数来获取实时最近的位姿更新和获取一个指定时间的位姿测量值的函数。返回的数据主要由两部分组成：平移向量和旋转四元数。位姿配置为特定的<strong>引用帧对</strong>，必须指定一个目标帧及它相对应的基础帧，给出的数据是目标帧相对于基础帧的相对位姿。</p>
  <p style="text-align: right; color: gray;"><br>2017-03-28 10:40:57</p>
        </div>
      </div>
      <footer>
        <p>
          JinJay's blog<a href="https://github.com/jinjaysnow" target="_blank">@JinJay</a>.
        </p>
        <script src="http://s4.cnzz.com/z_stat.php?id=1253269299&amp;web_id=1253269299" language="JavaScript"></script>
      </footer>
      </main>
    </div>
  </body>
</html>

